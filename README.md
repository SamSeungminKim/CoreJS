### ex1_01
```
[변수 선언]
- a는 식별자(즉, 변수명)
```

### ex1_02
```
[변수 선언과 할당]
- 변수 a에 데이터 할당
```

### ex1_03
```
[불변성]
- 변수 영역과 데이터 영역 개념
- 값을 변경하면 데이터영역에 있는 기존 값이 변경되는 것이 아니라(기존것 불변), 데이터영역에 별개로 새로운 값이 만들어진다.
```

### ex1_04
```
[참조형 데이터의 할당]
- 기본형 데이터와의 차이는 '객체의 변수(프로퍼티) 영역'이 별도로 존재하며, 그 값들은 불변값으로 동일하게 데이터 영역에 위치함.
```

### ex1_05
```
[참조형 데이터의 프로퍼티 재할당]
```

### ex1_06
```
[중첩된 참조형 데이터(객체)의 프로퍼티 재할당]
- 참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당 (중첩 객체)
```

### ex1_07
```
[변수 복사]
```

### ex1_08
```
[변수 복사 이후 값 변경 결과 비교(1)]
- 객체의 Property 변경시
- obj2.c를 20으로 바꾸면 동일한 주소를 바라보는 obj1.c도 20으로 변경됨.
```

### ex1_09
```
[변수 복사 이후 값 변경 결과 비교(2)]
- 객체 자체를 변경했을 때
- obj2를 새로 만들었기 때문에 obj1과는 다른 주소를 바라보므로 obj1.c은 그대로 10이 유지됨.
```

### ex1_10
```
[객체의 가변성에 따른 문제점]
- 값으로 전달받은 객체 newUser에 변경을 가하니 user2 뿐만아니라 원본 객체 user가 함께 변함.
```

### ex1_11
```
[객체의 가변성에 따른 문제점의 해결 방법]
- 값으로 전달받은 객체를 변경하는 대신, 새로 객체를 만들어서 Return 하면 원본 객체 user가 변하는 것을 막을 수 있음.
```

### ex1_12
```
[기존 정보를 복사해서 새로운 객체를 반환하는 함수]
- 얕은 복사
```

### ex1_13
```
[CopyObject를 이용한 객체 복사]
- for in 문법을 이용해 result 객체에 target 객체의 Property 복사 (얕은 복사)
```

### ex1_14
```
[중첩된 객체에 대한 얕은 복사]
- urls 내부의 property는 복사가 이루어지지 않고(얕은 복사), user, user2 모두 동일한 주소를 가르키고 있어 하나가 바뀌면 같이 바뀜.
```

### ex1_15
```
[중첩된 객체에 대한 깊은 복사]
- urls 내부의 property는 복사가 이루어지지 않았기 때문에 user2.urls를  copyObject를 활용 추가적으로 복사하면 각각 다른 주소를 가르키게 되어 개별 변경 가능.
```

### ex1_16
```
[객체의 깊은 복사를 수행하는 범용 함수]
- 객체 내부의 property 복사를 재귀적으로 호출하여 깊은 복사 수행하는 함수
```

### ex1_17
```
[깊은 복사 결과 확인]
- copyObjectDeep 함수를 이용하여 깊은 복사는 수행했으나, 객체 obj.b.d는 length 2인 배열(Array)인 반면, 복사된 obj2.b.d는 배열이 아닌 Object로 바뀌었음.
```

### ex1_18
```
[JSON을 활용한 간단한 깊은 복사]
- 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸는 복사. 다만, JSON으로 변경할 수 없는 내부 Mothod(function) 등은 복사가 되지 않음.
```

### ex1_19
```
[자동으로 undefined를 부여하는 경우]
- 값을 대입하지 않은 변수에 접근시, 객체 내부에 존재하지 않는 프로퍼티에 접근시, return 문이 없는 함수의 실행 결과시 undefined를 반환함.
```

### ex1_20
```
[undefined와 배열]
- 빈 배열을 만들거나 배열 크기를 할당해도 내부는 비어 있는 배열과 undefined를 할당한 배열의 차이 비교.
```

### ex1_21
```
[빈요소와 배열의 순회]
- '비어있는 요소'는 순회와 관련된 배열 메서드들의 순회 대상에서 제외됨.
```

### ex1_22
```
[undefined와 null의 비교]
- null은 object이고, 사용자는 undefined를 사용하는 대신 null을 사용하라.
```


### ex2_01
```
[실행 컨텍스트와 콜 스택]
- inner 함수에서 a는 외부환경(Outer)에도 정의 되어 있지 않으므로 undefined로 출력되나, outer 함수에서는 a가 외부환경(Global)에 정의되어 있고 1이 Assign 되어 있으므로 1이 출력 됨.
```

### ex2_02
```
[매개변수와 변수에 대한 호이스팅(1)]
- 원본 코드
- 1, undefined, 2가 출력 될 것 같지만, Hoisting에 의해 변수 x는 동일한 1개만 있고, 1, 1, 2가 출력 됨.
```

### ex2_03
```
[매개변수와 변수에 대한 호이스팅(2)]
- 매개변수를 변수 선언/할당과 같다고 간주해서 변환한 상태
- 역시 1, undefined, 2가 출력 될 것 같지만, Hoisting에 의해 변수 x는 동일한 1개만 있고, 1, 1, 2가 출력 됨.
```

### ex2_04
```
[매개변수와 변수에 대한 호이스팅(3)]
- 호이스팅을 마친 상태
- 변수 x는 3번 선언 되었지만 1개만 있고, 1, 1, 2가 출력되는 것이 명확함.
```

### ex2_05
```
[함수 선언의의 호이스팅(1)]
- 원본 코드
- undefined, bbb, function:b가 출력 될 것 같지만, 변수 b 및 함수 b가 Hoisting에 의해 끌어올려져, 실행될 때는 function:b, bbb, bbb가 출력 됨.
```

## ex2_06
```
[함수 선언의의 호이스팅(2)]
- 호이스팅을 마친 상태
- Hoisting을 마치면 변수 b 및 함수 b가 맨위에 있고, 순서대로 실행 되므로 function:b, bbb, bbb가 출력 되는 것이 명확함.
```

## ex2_07
```
[함수 선언의의 호이스팅(3)]
- 함수 선언문을 함수 표현식으로 바꾼 코드
- Hoisting이 끝난 상태에서의 함수 선언문은 함수명으로 선언한 변수에 함수를 할당한 것처럼 여길수 있기 때문에 function:b, bbb, bbb가 출력 되는 것이 명확함.
```

## ex2_08
```
[함수를 정의하는 세가지 방식]
- 함수 선언문으로 선언한 a, 함수 표현식으로 작성한 b, 기명 함수 표현식으로 선언한 C는 보이지만 d는 보이지 않음(ReferenceError: d is not defined).
- a = f a() { }
- b = f() { }
- C = f d() { }
- 다만, C 함수 내부에서 d는 사용 할 수 있음.
```
